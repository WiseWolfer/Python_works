# This is a sample Python script.
import math as m
# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.

import math as m
import copy
from copy import copy, deepcopy
def print_hi(name):
    # Use a breakpoint in the code line below to debug your script.
    print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    print_hi('PyCharm')

# если в итоге будем вводить текст, то его нужно вводить в двойных кавычках!!!
    # res = eval(input("Введите что-нибудь: "))
    # if type(res) == int:
    #     #если число
    #     print("Вы ввели число!!")
    # else:
    #     #если что-то другое
    #     print("Вы ввели не целое число, а что-то другое\n")
    # print("Работа завершена!!")
    # res = eval(input("Введите что-нибудь: "))
    # resType = type(res)
    # if resType == int:
    #     print("Это число!!")
    # if resType == float:
    #     print("Перед нами действительное число!")
    # if resType != int and resType != float:
    #     print("Это текст!!")
    # ## eval() - достает из строки спрятанное число и возвращает его с типом int
    # res = eval(input("Введите что-нибудь: "))
    # resType = type(res)
    # if resType == int:
    #     print("Это число!!")
    # elif resType == float:
    #     print("Перед нами действительное число!")
    # else:
    #     print("Это текст!!")
    #
    # print("Сумма натуральных чисел")
    # n = 100 # кол-во слагаемых
    # text = "1+2+...+" + str(n) + " ="
    # i = 1 # итерационная переменная для оператора цикла
    # s = 0 # переменная для записи суммы
    # while i <= n:
    #     s += i
    #     i += 1
    # print(text, s)

#     n = 100  # кол-во слагаемых
#     text = "1+2+...+" + str(n) + " ="
#     i = 1  # итерационная переменная для оператора цикла
#     s = 0  # переменная для записи суммы
#     while True:
#         s += i
#         i += 1
#         if i > n:
#             break
#     print(text, s)

# n = 100  # кол-во слагаемых
# text = "1+2+...+" + str(n) + " ="
# s = 0  # переменная для записи суммы
# for i in range(1, n+1):
#     s += i
# print(text, s)
# # тоже самое только короче
# print(sum(range(1, n+1)))

# Текст для оператора цикла
# txt = "Python"
# # Переменная для нумерации букв
# i = 1
# for s in txt:
#     # Формируем вспомогательный текст
#     t = str(i) + "-я буква:"
#     # Выводим сообщение: сначала индекс, потом букву
#     print(t, s)
#     # изменяем число букв
#     i += 1
# print("Работа программы завершена!")
#
# myList = [1.3 + 2j, 'ПИТОН', 4.0]
# print("Список: ", myList)
# for s in myList:
#     if type(s) == str:
#         print("В списке есть строка!!")
#         break
# else:
#     print("В списке нет текстовых эл-тов!!")
# вложенные циклы, поиск элементов из двух списков
# print("Поиск совпадающих элементов в списках")
# A = [2, False, 9.1, 2-1j, 'hello', 'Python']
# B = [5, 3, 'HELLO', 7, 12.5, 'Python', True, False]
# print("1-й список: ", A)
# print("2-й список: ", B)
# print("Совпадают:")
# i = 0
# for a in A:
#     i += 1
#     j = 0
#     for b in B:
#         j += 1
#         if a == b:
#             txt = str(i) + "-й элемент из первого списка и "
#             txt = txt + str(j) + "-й элемент из второго списка"
#             print(txt)
#         else:
#             continue
# print("Поиск закончен!!")
# See PyCharm help at https://www.jetbrains.com/help/pycharm/

# Обработка исключений
# print("Решаем уравнение ax = b")
# try:
#     a = float(input("Введите а: "))
#     b = float(input("Введите b: "))
#     x = b/a
#     print("Решение уравнения: ", x)
# except ZeroDivisionError:
#     print("На ноль делить нельзя!")
#
# print("Работа программы завершена!!")

# print("Решаем уравнение ax = b")
# try:
#     a = float(input("Введите а: "))
#     b = float(input("Введите b: "))
#     x = b/a
#     print("Решение уравнения: ", x)
# # обработка ошибки при делении на 0
# except ZeroDivisionError:
#     print("На ноль делить нельзя!")
# # обработка корректности введенных данных(в случае введенной строки - будет ошибка)
# except ValueError:
#     print("Нужно было ввести число!")
# print("Работа программы завершена!!")



# функции
# def your_name():
#     print("Добрый день!")
#     name = input("Введите ваше имя: ")
#     return name
# def say_hello(txt):
#     print("Здравствуйте," + txt + '!')
# my_name = your_name()
# say_hello(my_name)
# function, which calculates exp
# def my_exp(x,n):
#     s = 0 # стартовое значение суммы ряда
#     q = 1 # начальное значение добавки
#     for k in range(n+1):
#         s += q # добавка к сумме
#         q *= x/(k+1) # новая добавка
#     # результат функции
#     return s
# # Проверяем результат вычисления функцмм
# # Аргумент для экспоненты
# x = 1
# # n -> кол-во слагаемых в сумме
# #n = int(input("Введите кол-во слагаемых в сумме:"))
# # оператор цикла для многократного
# # вызова функции вычисления экспоненты
# for n in range(3):
#     # Отображаем результат вызова
#     # функции экспоненты
#     print("n =", n, "->", my_exp(x, n))
#
#
# def factorial(n):
#     if n >= 0:
#         result = 1
#         for i in range(1, n+1):
#             result *= i
#     else:
#         print("Введите положительное число!!")
#     return result
# num = int(input("Введите число для вычисления факториала: "))
# res = int(factorial(num))
# print(res)
# считаем экспоненту через встроенную библиотеку
# res = m.exp(11)
# print(res)

# 1-ая функция с 1 аргументом
# У аргумента есть значение по умолчанию
# def print_txt(txt = "значение по умолчанию"):
#     print(txt)
# # 2-ая функция с 2-мя аргументами.
# # У второго аргумента есть значение по умолчанию
# def show_args(a, b = "Второй аргумент не указан"):
#     print(a, b)
# # 3-я функция с 2-мя аргументами.
# # У аргументов есть значения по умолчанию
# def my_func(x = "1-й аргумент x.", y = "2-ой аргумент y."):
#     print(x, y)
#
# #передаем аргумент
# print_txt("Аргумент указан явно.")
# # непередаем аргумент
# print_txt()
#
# show_args("Первый аргумент.", "Второй аргумент.")
# show_args("Первый аргумент.")
#
# my_func()
# my_func("Один из аргументов.")
# my_func(y="Один из аргументов.")
# #позволяет забросить несколько элементов через список( аргумент со звездочкой)
# def get_sum(*nums):
#     s = 0
#     for a in nums:
#         s += a
#     return s
#
# result = get_sum(1, 3, 5, 2)
# print(result)
#
# # возможность присваиваивать имя функции переменной
# # исходная функция
# def my_func(txt):
#     print("Функция my_func:", txt)
# # переменной присваивается имя функции
# new_func = my_func
# # теперь new_func ссылается на объект функции
# new_func("вызов через функцию new_func")

# метод последовательных приближений
# описание функции решения уравнения
# def solve_eqn(f, x0, n):
#     # Начальное приближение для корня
#     x = x0
#     # Оператор цикла для вычисления приближений для решения
#     for k in range(1, n+1):
#         x = f(x) # итерационная формула
#     # результат функции
#     return x
# # Функция, определяющая первое уравнение
# def eqn_1(x):
#     # значение функции
#     return (x ** 2 + 5) / 6
# # Функция, определяющая второе уравнение
# def eqn_2(x):
#     # значение функции
#     return (6 * x - 5) ** 0.5
# # решаем первое уравнение
# x = solve_eqn(eqn_1, 0, 10)
# print("Решение первого уравнения: x =", x)
# # решаем второе уравнение
# x = solve_eqn(eqn_2, 4, 10)
# print("Решение второго уравнения: x =", x)

# Рекурсия
# числа Фиблначчи)

# def Fib(n):
#     if n == 1 or n == 2:
#         return 1
#     else:
#         return Fib(n-1) + Fib(n-2)
#
# print("Fibonachi numbers: ")
# for i in range(1, 16):
#         print(Fib(i), end=" ")
# # рекурсия для решения уравнений
# def solve(f, x0, n):
#     #Начальное приближение
#     if n == 0:
#         return x0
#     # Рекурсивное соотношение
#     else:
#         return solve(f, f(x0), n-1)
# def exn(x):
#     return (x ** 2 + 5) / 6
# def exn_2(x):
#     # значение функции
#     return (6 * x - 5) ** 0.5
# x = solve(exn, 0, 10)
# print("\nРешение уравнения : x =", x)
# x = solve(exn_2, 4, 10)
# print("Решение уравнения : x =", x)

# Лямбда функции

# def find_value(f,x):
#     print("x =", x, "-> f(x) =", f(x))

# my_func = lambda x: 1 / (1 + x ** 2)
# find_value(my_func, 2.0)
# find_value(lambda x: x * (1-x), 0.5)
# # в скобках после лямбда выражения мы задаем значения аргументов
# z = 1 + (lambda x,y: x * y - x ** 2) (2, 3) ** 2
# print("z = ", z)
# # идея функции в том,
# # что, используя лямбда функцию внутри функции,
# # можно  при вызове этой функции воспользоваться ее же именем my_pow(n) и дать ей аргументы (x)
# # тогда получим: my_pow(n)(x) - результат функции -> является сама функция

# def my_pow(n):
#     return lambda x: x ** n
# for n in range(1,4):
#     for x in range(1,11):
#         print(my_pow(n)(x), end=" ")
#     # переход на новую строку
#     print()

# глобальные и локальные переменные

# глобальная переменная
# x = 100
# def test_vars():
#     # здесь x - локальная переменная
#     x = "локальная переменная"
#     print("В теле функции x =", x)
# test_vars()
# print("Вне функции x =", x)
#
# def test_vars():
#     print("В теле функции x =", x)
# x = "глобальная переменная"
# test_vars()
# print("Вне функции x =", x)
#
# x = 100
# def test_vars():
#     # здесь x - локальная переменная
#     global x,y
#     print("В теле функции x =", x)
#     # значение глобальной переменной y
#     y = 200
#     print("В теле функции y =", y)
#     # значение глобальной переменной x
#     x = 300
# test_vars()
# print("Вне функции x =", x)
# print("Вне функции y =", y)

# Вложенные функции
# функция для вычисления суммы квадратов чисел
# def Full_sq_sum():
#     # Вложенная функция для считывания кол-ва слагаемых
#     def get_n():
#         n = int(input("Слагаемых в сумме: "))
#         return n
#     # вложенная функция для вычисления суммы квадратов натуральных чисел
#     # результатом является сама функция
#     def find_sq_sum():
#         s = 0
#         for i in range(1, n + 1):
#             s += i ** 2 #новое слагаемое в сумме
#         return s
#     # часть функции sq_sum() -> из нее вызывает функцию получения элементов и записывает число эл-ов и возвращает результат суммы
#     n = get_n()
#     return find_sq_sum()
# # Вычисляем сумму квадратов чисел
# z = Full_sq_sum
# print("Сумма квадратов равна: ", z())

#Вычисление факториала и двойного факториала
#
# def factor(mode=True):
#     # Вложенная функция для вычисления
#     # факторила числа
#     def sf(n):
#         s = 1 # начальное значение произведения
#         i = n # стартовое значение индекса
#         while i >1:
#             s *= i
#             i -= 1
#         return s
#     def df(n):
#         s = 1  # начальное значение произведения
#         i = n  # стартовое значение индекса
#         while i > 1:
#             s *= i
#             i -= 2
#         return s
#     if mode:
#         return sf
#     else:
#         return df
# print("5! =", factor()(5))
# print("5! =", factor(True)(5))
# print("5!! =", factor(False)(5))
#
# # Второй варинат факториал
# def factor(mode=True):
#     # Вложенная функция для вычисления
#     # факторила числа
#     def f(n, d):
#         s = 1 # начальное значение произведения
#         i = n # стартовое значение индекса
#         while i >1:
#             s *= i
#             i -= d
#         return s
#     # значение декремента для индекса
#     d = 1 if mode else 2
#     # результат функции
#     return lambda n: f(n,d) # Лямбда-функция
# print("5! =", factor()(5))
# print("5! =", factor(True)(5))
# print("5!! =", factor(False)(5))
#
# # 3ий вариант факториала
# # функция факториала
# def factorial(n):
#     if n == 1:
#         return 1
#     else:
#         # Рекурсия
#         return n * factorial(n-1)
# # функция двойного факториала
# def dfactorial(n):
#     if n == 1 or n == 2:
#         return n
#     else:
#         # Рекурсия
#         return n * factorial(n-2)
# def factor(mode=True):
#     return factorial if mode else dfactorial
#
# print("5! =", factor()(5))
# print("5! =", factor(True)(5))
# print("5!! =", factor(False)(5))

# Вычисление производной
# Функция для вычисления производной
# def D(f):
#     # Вложенная функция вычисляет приближенное значение производной
#     def df(x, dx=0.001):
#         return (f(x+dx)-f(x))/dx
#     return df
# # первая функция для дифференцирования
# def f1(x):
#     return x ** 2
# # вторая функция для дифференцирования
# def f2(x):
#     return 1 / (1+x)
# # Функция для отображения производной в нескольких точках.
# # Аргументы такие:
# # F - приближенная произодная
# # Nmax - кол-во точек (минус один)
# # Xmax- правая граница по аргументу
# # dx - приращение аргумента
# # f - производная (аналитически)
# def show(F, Nmax, Xmax, dx, f):
#     # точки, в которых вычисляются производные
#     for i in range(Nmax+1):
#         # Значение аргумента
#         x = i * Xmax / Nmax
#         # Приближенное или точное значение производной
#         print(F(x), F(x, dx), f(x), sep=" -> ")
# # Производная для первой функции
# F1 = D(f1)
# # Производная для второй функции
# F2 = D(f2)
# # Значения в разных точках
# # производной для первой функции
# print("Производная (x**2)'= 2x:")
# show(F1, 5, 1, 0.01, lambda x: 2*x)
# # Значения в разных точках
# # производной для второй функции
# print("Производная (1/(1+x))'= -1/(1+x)**2:")
# show(F2, 5, 1, 0.01, lambda x: -1/(1+x)**2)

# Решение диф. уравнения методом Эйлера
# def solve_deqn(f,x0,y0,x):
#     # Кол-во отрезков, на которое делится интервал
#     # поиска решения уравнения
#     n = 1000
#     # Расстояние между соседними узловыми точками
#     dx = (x-x0)/n
#     # Начальная точка
#     x = x0
#     # Начальное значение функции
#     y = y0
#     # Оператор цикла для вычисления решения
#     for k in range(1, n+1):
#         # Значение функции в узловой точке
#         y = y + dx * f(x, y)
#         # Следующая узловая точка
#         x = x + dx
#     # Результат функции
#     return y
# # Функция определяющая дифференциальное уравнение
# def dif_eqn(x,y):
#     return 2 * x - y
# # Функция точного решения уравнения
# def y(x):
#     return 2 * (x-1) + 5 * m.exp(-x)
# # Шаг приращения по аргументу
# h = 0.5
# # Вычисление результата для нескольких значений аргумента
# for k in range(0, 6):
#     # Значение аргумента
#     x = k * h
#     print("Числовое решение:")
#     # Числовое решение
#     print("x =", x, "-> y(x) =", solve_deqn(dif_eqn, 0, 3, x))
#     print("Точное решение:")
#     # Точное решение
#     print("x =", x, "-> y(x) =", y(x))

# Списки и кортежи

# symbs = list("Python")
# data = ["text", 100, [5,10]]
# print(symbs, data, sep="\n")
# # перебираем внутри списка степени двойки до 10
# pows_of_two = [2**i for i in range(11)]
# print(pows_of_two)

# Кроме диапазона индексной переменной
# можно указать условие для включения элемента в список
# nums_list = [7*i+1 for i in range(20) if i % 4 == 3]
# print(nums_list)
# first_el = nums_list[0]
# last_el = nums_list[-1]
# length = len(nums_list) #длина списка
# print(first_el, last_el, length)
# nums = [1,2,3]
# nums[1] = 10
# print(nums)
# # выводим срез из трех элементов со 2 по 4 включительно
# print(symbs[1:4])
# symbs[1:] # c первого индекса берем до конца списка срез
# symbs[:6] # срез с первого элемента по последний
# symbs[7:6] # пустой список будет, так как первый индекс > второго
# # записываем копию списка (весь список)
# sp = nums[:]
# print(sp)
# # идем с последнего элемента по первый с шагом -1
# m = [1, 5, 10, 15, 20, 25]
# print(m[-1:-5:-1])
# # перебираем все элементы с последнего по первый включительно с шагом -1
# print(m[::-1])
# # перебираем все элементы с шагом 1 с последнего по 1 включительно (хотя второй индекс выходит за диапазон)
# print(m[:-10:-1])
# # перебираем все элементы с шагом 1 с последнего по 1 включительно (хотя второй индекс выходит за диапазон)
# print(m[10:-10:-1])
# # перебираем все элементы от последнего,но не до первого так как его индекс 0, а выбираемые индесы должны быть > 0
# print(m[10:0:-1])
# s = [10, 20, 30]
# # вставляем что-то как один элемент в список
# s.append([1,2])
# print(s)
# # вставляем в список элемент(в моем случае список) как отдельные элементы: 3 и 4
# s.extend([3, 4])
# print(s)
# s = [10, 20, 30]
# s.insert(1, -5)
# print(s)
# s.insert(1, [1, 2])
# print(s)
# s[2:2] = [3, 4]
# print(s)
# s[2:3] = [100, 200]
# print(s)
# # объединение списков через конкатенацию
# print([2,3] +[1,4,5])
# #удаление содержимого списка по индексам
# s[0:9] = []
# print(s)
#
# sp = [i * (10 - i) for i in range(11)]
# print(sp)
# print("Удаляем элемент", sp.pop(5))
# print(sp)
# sp.remove(21)
# print(sp)
# del sp[3]
# print(sp)
# sp[2:5] = []
# print(sp)
# sp[1:3] = [-1, -2, -3, -4, -5]
# print(sp)
# # элемент in переменная списка - проверка на вхождение элемента в этот список
# # True вернется, если элемент есть в списке
# # False вернется, если элемента нет в списке
# print(-2 in sp)
# print(sp.index(-3)) # Результатом будет номер элемента -3 в списке
# print(sp.index(0, 3))
# print(sp.count(0)) # считаем сколько элементов находится в списке с этим именем (сколько 0 в списке в моем случае)
# num = [1, 2, 3, 4]
# res = num.reverse() #методом reverse() мы поменяли порядок чисел в списке
# print(res) # при выводе результат метода ничего не возвращает
# print(num) # вывод списка в обратном порядке
# num = [i for i in reversed(num)] # меняем список на прямой порядок
# print(num) # вывод списка в прямом порядке
#
# # Сортировка списка в прямом порядке
# num.sort()
# print(num)
# # Сортировка списка в обратном порядке
# num.sort(reverse=True)
# print(num)
# # тоже самое только уже не методами, а функциями
# print(sorted(num))
# print(sorted(num, reverse=True))
# print(min(num))
# print(max(num))
# print(sum(num))

# s = [10, 20, 30]
# # копируем элементы в новый список из исходного
# # при это элементы будут изменяться только в новом списке -> теперь эти списки разные
# b = s[:]
# b[1] = 100
# print(b, s, sep="\n")
#
# a = [10, 20, 30]
# print("List a:", a)
# b = a
# c = a[:] # создаем копию с помощью среза
# d = a.copy()  # создаем копии списка с помощью метода copy()
# print("List b:", b)
# print("List c:", c)
# print("List d:", d)
# print("Change value of a[1] = 0.")
# a[1] = 0
# print("List a:", a)
# print("List b:", b)
# print("List c:", c)
# print("List d:", d)
#
# x = [10, 20, [100, 200], 30, [300, 400]]
# y = x[:]
# z = x.copy()
# print("List x", x)
# print("List y:", y)
# print("List z:", z)
# print("Change value of elements: x[2][1] = 0 and x[4] = 0.")
# x[2][1] = 0
# x[4] = 0
# print("list x:", x)
# print("list y:", y)
# print("list z:", z)
#
# # Глубокое копирование через deepcopy() помогает избавиться от изменения в копируемом списке,
# # когда мы изменили элемент в исходном списке
# A = [[10, 20], [[30, 40], [50, 60]]]
# B = copy.deepcopy(A)
# print("list A:", A)
# print("list B:", B)
# print("Change value of elements: A[0][1] = 0 and A[1][1][1] = 0.")
# A[0][1] = 0
# A[1][1][1] = 0
# print("list A:", A)
# print("list B:", B)

# модуль генерирования случайных чисел
import random
# Функция для отображения содержимого списка
# Аргумент функции отображаемый список
# def show(a):
#     # Длина списка
#     n = len(a)
#     print(n, "D - вектор: <", sep="", end="")
#     for i in range(n-1):
#         # Отображение элементов списка
#         print(a[i], end="|")
#     # Отображение последнего элемента списка
#     print(a[n-1], ">", sep="")
# # Функция для создания списка со случайными
# # целочисленными элементами. Аргумент функции -
# # кол-во элементов  в списке
# def rand_vector(n):
#     r = []
#     for i in range(n):
#         # добавляем в конец списка случайное целое число от 0 до 6
#         r.append(random.randint(0, 6))
#     return r
# # Функция для создания списка со случайными
# # целочисленными элементами. Аргумент функции -
# # кол-во элементов  в списке
# def scal_prod(a,b):
#     Na = len(a)
#     Nb = len(b)
#     N = min(Na, Nb)
#     s = 0
#     for i in range(N):
#         s += a[i] * b[i]
#     return s
# # Инициализация генератора случайных чисел
# random.seed(2014)
# # Первый случайный вектор
# a = rand_vector(3)
# # Второй случайный вектор
# b = rand_vector(5)
# show(a)
# show(b)
# p = scal_prod(a, b)
# print("Скалярное произведение:", p)

# не берем все из random так как выше уже подключили random
#from random import *

# Фукция для создания матрицы со случайными элементами
# def rand_matrix(n, m):
#     # Создаем матрицу с элементами - случайными числами
#     A = [[random.randint(0, 9) for j in range(m)] for i in range(n)]
#     return A
#
# # Фукция для создания единичной матрицы
# def unit_matrix(n):
#     # Единичная матрица
#     A = [[int(i == j) for i in range(n)] for j in range(n)]
#     return A
#
# # Фукция для вычисления произведения квадратных матриц
# def mult_matrix(A, B):
#     # размер матрицы
#     n = len(A)
#     # Матрица-результат с начальными нулевыми значениями
#     C = [[0 for i in range(n)] for j in range(n)]
#     # Первый индекс
#     for i in range(n):
#         # Второй индекс
#         for j in range(n):
#             # Внутренний индекс, по которому берется сумма
#             for k in range(n):
#                 # Добавляем слагаемое в сумму
#                 C[i][j] = A[i][k]*B[k][j]
#     return C
#
# # функция для отображения матрицы
# def show_matrix(A):
#     # Перебор строк матрицы
#     for a in A:
#         # Перебор элементов в строке матрицы
#         for b in a:
#             # Отображаем элементы матрицы
#             print(b, end=" ")
#         # Переход на новую строку (при выводе на консоль)
#         print()
#
# random.seed(2014)
# # Матрица со случаными числами
# A = rand_matrix(3, 5)
# print("Список:", A)
# print("Эта же матрица")
# show_matrix(A)
# # Единичная матрица
# E = unit_matrix(4)
# print("Единичная матрица:", E)
# A1 = rand_matrix(3, 3)
# A2 = rand_matrix(3, 3)
# A3 = mult_matrix(A1, A2)
# print("Первая матрица:")
# show_matrix(A1)
# print("Вторая матрица:")
# show_matrix(A2)
# print("Произведение матриц:")
# show_matrix(A3)
#
# # способы получения кортежей
# a = tuple()
# a = (100,)
# a = 7, 12, 21, 16, 18
# print(a)
#
# # создаем пустой кортеж
# a = tuple()
# print(a)
# # создаем кортеж на основе списка
# b = tuple([10, 20, 30])
# print(b)
# # Создаем кортеж на основе текста
# c = tuple("Python")
# print(c)
# # объединение кортежей
# a = b + (40, [1, 2, 3], 60)
# print(a)
# # Получение среза 2 по 4 элемент
# print(a[2:5])
# # Получаем индекс элемента со значением 40
# print(a.index(40))
# # Получаем кол-во элементов [1, 2, 3] в кортеже
# print(a.count([1, 2, 3]))
# # Определяем длину кортежа
# print(len(a))
# # in - определяет входит или не входит элемент в кортеж
# # Вернет True(если входит) или False(если не входит)
# print(60 in a)

# Множества, словари и текст

# A = [1, 30, "text", True, 30, 100, False]
# print("Список A:", A)
# B = set(A)
# print("Множество B:", B)
# C = {1, 30, "text", True, 30, 100, False}
# print("Множество C:", C)
# print("Равенство множеств:", B == C)
# print("Элемент 1 во множестве C:", 1 in C)
#
# # Первое множество (множество А)
# A = {1, 2, 3, 4}
# print("Множество А:", A)
# # Второе множество (множество B)
# B = {3, 4, 5, 6}
# print("Множество B:", B)

# объединение множеств А и В
# C = A | B
# print("Множетво C = A | B:", C)
# # Объединение множеств -> создание нового множества
# print("Множество A.union(B):", A.union(B))
# print("Множество B.union(A):", B.union(A))
# # Изменяем множество А, расширение старого множества
# A.update(B)
# print("Множество А:", A)
# B = B | {-1, -2, -3}
# print("Множество B:", B)
# C |= {7, 8, 9}
# print("Множетво C: ", C)

# Пересечение множеств
# A = {1, 2, 3, 4}
# print("Множество A:", A)
# B = {3, 4, 5, 6}
# print("Множество B:", B)
# # Пересечение множеств запишем в C
# C = A & B
# print("Множество C = A & B:", C)
# print("Множество A.intersection(B)", A.intersection(B))
# print("Множество B.intersection(A)", B.intersection(A))
# # Изменяем множество A
# A.intersection_update(B)
# print("Множество A:", A)
# # Изменяем множество B
# B = B & {4, 6, 8, 10}
# print("Множество B:", B)
# C &= {1, 2, 3}
# print("Множество C:", C)
#
# # Разность множеств
# A = {1, 2, 3, 4}
# print("Множество A:", A)
# B = {3, 4, 5, 6}
# print("Множество B:", B)
# # Разность множеств (множество C)
# C = A - B
# print("Множество C = A - B:", C)
# # Разность множеств
# print("Множество A.difference(B):", A.difference(B))
# print("Множество B.difference(A):", B.difference(A))
# # Изменяем множество A
# A.difference_update(B)
# print("Множество A:", A)
# # Изменяем множество B
# B = B - {4, 6, 8, 10}
# print("Множество B:", B)
# # Изменяем множество C
# C -= {1, 3, 5}
# print("Множество C:", C)

# Симметрическая разность множеств
# Первое множество (множество A)
# A = {1, 2, 3, 4}
# print("Множество A:", A)
# B = {3, 4, 5, 6}
# print("Множество B:", B)
# # Симметрическая разность множеств (множество C)
# C = A ^ B
# print("Множество С:", C)
# print("Множество A.symmetric_difference(B)", A.symmetric_difference(B))
# print("Множество B.symmetric_difference(A)", B.symmetric_difference(A))
# # Изменяем множество A
# A.symmetric_difference_update(B)
# print("Множество A:", A)
# # Изменяем множество B
# B = B ^ {4, 6, 8, 10}
# print("Множество B:", B)
# # Изменяем множество C
# C ^= {1, 3, 5}
# print("Множество C:", C)

# использование множеств
# n = 100
# E = {s for s in range(1, n + 1)}
# # множество чисел, которые при делении на 5 дают остаток 1
# A1 = {s for s in E if s % 5 == 2}
# # множество чисел, которые при делении на 5 дают остаток 4
# A2 = {s for s in E if s % 5 == 4}
# A = A1 | A2
# # множество чисел, которые при делении на 7 дают остаток 3
# B = {s for s in E if s % 7 == 3}
# # множество чисел, которые при делении на 3 дают остаток 1
# C = {s for s in E if s % 3 == 1}
# # Множество чисел, которые при делении
# # на 5 дают в остатке 2 или 4, при деление на 7
# # дают в остатке 3, а при делении на 3 не дают
# # в остатке 1
# D = (A & B) - C
# print("Приведенные ниже числа от 1 до", n)
# print("1) при делении на 5 дают в остатке 2 или 4;")
# print("2) при деление на 7 дают в остатке 3;")
# print("3) при делении на 3 не дают в остатке 1;")
# print(D)
#
# # Второй вариант задачи выше
# n = 100
# D = {s for s in range(1, n + 1) if (s % 5 == 2 or s % 5 == 4) and s % 7 == 3 and s % 3 != 1}
# print("Приведенные ниже числа от 1 до", n)
# print("1) при делении на 5 дают в остатке 2 или 4;")
# print("2) при деление на 7 дают в остатке 3;")
# print("3) при делении на 3 не дают в остатке 1;")
# print(D)
#
# # Вариант 3 "Классический подход"
# n = 100
# D = set()
# for s in range(1, n+1):
#     if s % 5 == 2 or s % 5 == 4:
#         if s % 7 == 3:
#             if s % 3 != 1:
#                 D.add(s)
# print("Приведенные ниже числа от 1 до", n)
# print("1) при делении на 5 дают в остатке 2 или 4;")
# print("2) при деление на 7 дают в остатке 3;")
# print("3) при делении на 3 не дают в остатке 1;")
# print(D)

# Словари

# Список для формирования словаря
# A = [["Пушкин АС.", "Капитанская дочка"],
#      ["Чехов А.П.", "Вишневый сад"],
#      ["Толстой Л.Н.", "Война и мир"]]
#
# # создаем словарь на основе списка
# writers = dict(A)
# # отображаем содержимое словаря
# print("Словарь:")
# print(writers)
# print("Чехов написал пиьесу:", writers["Чехов А.П."])
# # Изменяем значение элемента словаря
# writers["Чехов А.П."] = "Каштанка"
# print("Словарь после изменения элемента:")
# print(writers)
# print()
# # перебор элементов словаря по ключу
# print("Авторы и их произведения.")
# for s in writers.keys():
#     print("Автор:", s)
#     print("Произведение:", writers[s])
#     print()
# # перебор элементов по значению
# for i in writers.values():
#     print("Произведение:", i)
# print()
# # перебор элементов по ключу и значению
# for j in writers.items():
#     print(j)
# print()
# # Создаем новый словарь
# lights = dict(красный="движение запрещено",
#               желтый="всем внимание",
#               зеленый="движение разрешено")
# # Проверяем содержимое словаря
# print("Новый словарь:")
# print(lights)
# # значение ключа
# color = "зеленый"
# print("Если горит", color, "свет, то", lights[color] + "!")
# print()
# # метод get() позволяет вывести значени по ключу, если ключ существует
# # если ключ не существует, то выведется None или второй аргумент(который можно задать)
# print(lights.get("синий", "Ничего не найдено!"))
# # создаем еще один словарь
# girls = {(90, 60, 90): "Света", (85, 65, 89): "Юля", (92, 58, 91): "Нина"}
# # проверяем содержимое еще одного словаря
# print("Ещё один словарь:")
# print(girls)
# # значение ключа
# params = (90, 60, 90)
# # обращение к элементу словаря по ключу
# print(girls[params] + ":", params)
#
# # Создаём словарь
# symbs = dict([["a", "первый"], ["b", "второй"]])
# # Создаем еще один словарь
# more_symbs = dict([["c", "третий"], ["d", "четвертый"]])
# # Добавляем второй словарь в первый
# symbs.update(more_symbs)
# # Содержимое словаря
# print("Словарь:", symbs)
# # Длина словаря
# print("Кол-во ключей в словаре", len(symbs))
# # доступ к элементу по ключу (ключ в словаре есть)
# print("Элемент  с ключом 'c':", symbs.get('c', "нет такого ключа!"))
# # Проверяем наличие ключа в словаре
# print("Наличие элемента с ключом 'c':", 'c' in symbs)
# # Удаляем элемент из словаря
# del symbs['c']
# # результат метода вернется в переменную a
# a = symbs.pop('d')
# print("Из словаря удалилось значение:", a)
# print("Словарь:", symbs)
# # Доступ к элементу по ключу (ключ в словаре есть)
# print("Элемент  с ключом 'c':", symbs.get('c', "нет такого ключа!"))
# # Проверяем наличие ключа в словаре
# print("Наличие элемента с ключом 'c':", 'c' in symbs)
# # Список ключей словаря
# print("Ключи словаря:", list(symbs.keys()))
# # Список значений элементов словаря
# print("Значения элементов словаря:", list(symbs.values()))
# # Содержимое словаря
# print("Содержимое словаря:", list(symbs.items()))
# # Удаляем элемент из словаря
# print("Удаляется элемент со значением:", symbs.pop('b'))
# print("Словарь:", symbs)
# # Очистка словаря
# symbs.clear()
# print("Словарь после очистки:", symbs)
# # Генератор словарей
# colors = ["красный", "желтый", "зеленый"]
# action = ["стоим", "ждем", "двигаемся"]
# a_dict = {colors[i]: action[i] for i in range(len(colors))}
# print("Словарь:", a_dict)

# Текстовые строки
# Создание текста
# txt = "Знание языка 'Python' - залог успеха."
# print(txt)
# txt = 'Знание языка "Python" - залог успеха.'
# print(txt)
# txt = "Знание языка \"Python\" - залог успеха."
# print(txt)
# txt = 'Знание языка \'Python\' - залог успеха.'
# print(txt)
# txt = "Знание языка 'Python'\
#  - залог успеха."
# print(txt)
# txt = "Знание языка 'Python'\n - залог успеха."
# print(txt)
# txt = """Знание языка
#         "Python"
#         - залог успеха."""
# print(txt)
#
# # Текстовые строки
# txt = "Мы изучаем " "Python"
# print(txt)
# print("Всего", len(txt), "букв")
# # Использован символ \t табуляции
# print("Индекс\tБуква")
# # отображения индекса и буквы
# for i in range(len(txt)):
#     # Приведем с помощью str()
#     # целочисленного типа к текстовому,
#     # обращение к букве по индексу
#     print(str(i) + ":  \t" + txt[i])
# print(txt[11:])
# # с помощью среза отображаем строку в обратном порядке
# print(txt[::-1])
# # текстовая строка
# word = "Java"
# # явная конкатенация строк и присваивание
# # переменной txt нового значения
# txt = txt[:3] + "не" + txt[2:11] + word
# print(txt)

# Регистр символов
# txt = "мы изучаем язык PYTHON"
# # все слова пишутся с заглавной буквы
# print(txt.upper())
# # все слова пишутся со строчной буквы
# print(txt.lower())
# # Первое слово пишется с большой буквы
# # остальные слова как в педложении(со строчной)
# print(txt.capitalize())
# # каждое слово с большой буквы(становится заголовком)
# print(txt.title())
# # Слова, которые были с маленькой буквы ->
# # теперь полностью написаны большими буквами
# # А строчные слова -> пишутся с большой буквы
# print(txt.swapcase())
# print(txt)
#
# # поиск и замена символов
#
# txt = """И.В. Гёте. "Фауст"(отрывок):
# Бессодержательную речь
# Всегда легко в слова облечь.
# Из голых слов, ярясь и споря,
# Возводят здания теорий.
# Словами вера лишь жива.
# Как можно отрицать слова?"""
# word = "слов"
# print(txt, end="\n\n")
# # считаем сколько раз встречается слово
# print("Подстрока встречается", txt.count(word), "раза")
# # выводим индекс первого вхождения в строку слова
# print("Первая позиция:", txt.index(word))
# # с помощью метода find(), указываем что ищем, а также с какой позиции
# # берем только первое вхождение и печатаем его индекс
# print("Следующая позиция:", txt.find(word, 69))
# # ищем только последнее вхождение слова в строку и печатаем его индекс
# print("Последняя позиция:", txt.rfind(word))
# # с помощью данного метода проверяем начинается ли строка с этих симовлов
# # возвращается True - если да, False - если нет
# print("В начале инициалы:", txt.startswith("И.В."))
# # с помощью данного метода проверяем заканчивается ли строка этими символом
# # возвращается True - если да, False - если нет
# # \n\n - оставляет пустую строку между выводами (два переноса строки делает)
# print("В конце знак вопроса:", txt.endswith("?"), end="\n\n")
# # Все одинаковые символы " " заменяем на _ при помощи метода replace()
# print(txt.replace(" ", "_"))
#
# # проверка текстовых значений
# print("123".isdigit(), "12.3".isdigit())
# print("abc".isalpha(), "abc123".isalpha())
# print("ab12".isalnum(), "ab12\n".isalnum())
# print("ABC".isupper(), "aBc".isupper())
# print("abc".islower(), "aBc".islower())
# print("Ab12 Ab12".istitle(), "Ab12 AB12".isdigit())
#
# txt = "_*_ABC_*_abc_*_"
# # метод lstrip удаляет элемент только слева от символа с начала строки
# print(txt.lstrip("_*_"))
# # метод rstrip удаляет элемент только слева от символа с начала строки
# print(txt.rstrip("_*_"))
# # метод strip удаляет элемент сначала и с конца строки (кроме середины)
# print(txt.strip("_*_"))
# # split делит строку по символу и записывает части строки в список
# # проходится поиском слева направо
# print(txt.split("*"))
# # split делит строку по символу и записывает части строки в список,
# # проходится поиском справа налево
# print(txt.rsplit("*"))
# # делает тоже самое, что и split, но результат записывает в кортеж
# # осуществляет поиск разделителя слева направо
# print(txt.partition("*"))
# # делает тоже самое, что и split, но результат записывает в кортеж
# # осуществляет поиск разделителя справа налево
# print(txt.rpartition("*"))
# # метод делит строку по символу перехода на новую строку
# print("abc \n ABC \n ***".splitlines())
# # метод соединяет список(текстовые части) с разделителем, через который вызывается метод
# print("_*_".join(["AAA", "BBB", "CCC"]))
# # метод соединяет список(текстовые части) с разделителем, через который вызывается метод
# print(txt.join(["AAA", "BBB", "CCC"]))
# # определяем по коду клавишу
# print(chr(97))
# # определяем по клавише её код
# print(ord('a'))
#
# # Выравнивание текста
# txt = "ABCDEFGH"
# # выравнивание текста по центру, ширина поля 20 (поле: "*      ABCDEFGH      *")
# print("*" + txt.center(20) + "*")
# # выравнивание текста по левому краю, ширина поля 20 (поле: "*      ABCDEFGH      *")
# print("*" + txt.ljust(20) + "*")
# # выравнивание текста по правому краю, ширина поля 20 (поле: "*      ABCDEFGH      *")
# print("*" + txt.rjust(20) + "*")
#
# # строка формата (методы форматирования)
# txt = "{0}жды {0} - будет {1}"
#
# # метод format подставляет в строку в {0} - свой первый аргумент
# # и {1} - второй аргумент
# print(txt.format("два", "четыре"))
# print(txt.format("три", "девять"))
#
# # Здесь также в строку в аргумент (в {0}) - передается аргумент метода .format()
# # (то что в круглых скобках)
# # после ":" происходит выравнивание {0:<20} по лев.краю и дается неменее 20 симв. на строку
# # происходит выравнивание {0:^20} по центру и дается неменее 20 симв. на строку
# # происходит выравнивание {0:>20} по прав.краю и дается неменее 20 симв. на строку
# print("Текст '{0}': {0:<20}.".format("abcdef"))
# print("Текст '{0}': {0:^20}.".format("abcdef"))
# print("Текст '{0}': {0:>20}.".format("abcdef"))
#
# # Вид аргументов **kwargs (работаем как со словарем)
# def brand(**brands):
#     for i in brands.keys():
#         print("Позиция(ключ) " + i +" : " + " Значение(марка) " + brands[i])
# brand(a = "Apple", s = "Samsung")
#
# # Вид аргументов *args (работаем как с картежем)
# def summa_args(*args):
#     print("Сумма чисел:", sum(args))
# summa_args(12, 13, 4, 5, 1, 10, 20)
#
# def arithm_mean(*nums):
#     counter = 0
#     for i in nums:
#         counter += 1
#     print("Среднее арифметическое 1 вар: ", sum(nums) // counter)
#     print("Среднее арифметическое 2 вар: ", sum(nums) // len(nums))
#
# arithm_mean(5,10,15,20,25)

# ООП (объектно-ориентированное программирование)

# Класс и экземпляры класса
# class MyClass:
#     # Метод экземпляра класса.
#     # Единственный аргумент метода self - ссылка
#     # на экземпляр класса, из которого вызывается метод
#     def say_hello(self):
#         # Методом отображается сообщение. Аргумент
#         # метода (ссылка self) явно не используется
#         print("Вас приветствует экземпляр класса!")
# # Создаем экземпляр класса
# obj = MyClass()
# # Вызывается метод экземпляра класса.
# # При вызове аргументы методу не пердаются
# obj.say_hello()
#
# # Поле экземпляра класса
# class MyClass:
#     # Метод для присвивания значения экзмепляру
#     # полю экзеипляра класса
#     def set(self, n):
#         print("Внимание! Присваивается значение!")
#         self.number = n
#     # метод считывания значения поля экземпляра
#     # поля экземпляра класса
#     def get(self):
#         # отображаем значения поля
#         print("Значение поля:", self.number)
# obj = MyClass()
# # вызывается метод экземпляра класса и
# # полю экземпляра класса присваивается
# # значение
# obj.set(100)
# # вызывается метод экземпляра класса и
# # отображается значения поля экземпляра класса
# obj.get()
#
# # Значение поля экземпляра класса
# class MyClass:
#     # если в классе нет ни методов, ни переменных, то пишем pass (пустой класс)
#     pass
# # Создем экземпляр класса
# obj = MyClass()
# # Присваивается значение полю number
# # экземпляр obj
# obj.number = 100
# print("Значение поля:", obj.number)
#
# # Конструктор экземпляра класса
# # создаем класс
# class MyClass:
#     # Конструктор
#     def __init__(self):
#         # присваивается значение полю
#         self.number = 0
#         print("Создан экземпляр класса!!!")
# # создается экземпляр класса
# obj = MyClass()
# print("Значение поля:", obj.number)
#
# # Аргументы конструктора
# class MyClass:
#     # Метод для присваивания значения полю
#     def set(self, n):
#         # полю number присваиваем значение
#         self.number = n
#     # Метод для отображения значения поля
#     def get(self):
#         print("Значение поля:", self.number)
#     # Конструктор с двумя аргументами.
#     # У второго аргумента есть значение
#     # по умолчанию
#     def __init__(self, n = 0):
#         # вызывается метод set для присваивания
#         # значения в поле number
#         self.set(n)
#         print("Создан экземпляр класса.")
#         # вызывается метод get() для считывания
#         # значения из поля number
#         self.get()
# # создается экземпляр класса
# a = MyClass()
# # создается ещё один экземпляр класса
# b = MyClass(100)
#
# # Деструктор экземпляра класса
# class MyClass:
#     def __init__(self):
#         print("Привет, всем!")
#     def __del__(self):
#         print("Всем пока!")
# print("Проверяем работу деструктора.")
# # создаем экземпляр класса
# obj = MyClass()
# print("Экземпляр класса создали. Теперь удалим его.")
# # удаляем экземпляр класса
# del obj
# print("Выполнение программы завершено.")
#
# # Поле объекта класса
# class MyClass:
#     # поле класса
#     name = "Класс MyClass"
#     # Метод для присваивания значения
#     # полю экземпляра класса
#     def set(self, n):
#         self.nickname = n
#     # поля экземпляра класса
#     def get(self):
#         print("Значение поля:", self.nickname)
#     # конструктор класса
#     def __init__(self, n):
#         # полю экземпляра класса
#         # присваивается значение
#         self.set(n)
#         # Отображается сообщение
#         print("Создан экземпляр класса.")
#         self.get()
# green = MyClass("Зеленый")
# # Обращение к полю класса через экземпляр класса
# print("Принадлежность:", green.name)
# # создается второй экщемпляр класса
# red = MyClass("Красный")
# # обращение к полю класса через экземпляр класса
# print("Принадлежность:", red.name)
# # полю класса присваивается значение
# MyClass.name = "Здесь могла быть Ваша реклама!"
# # Обращение к полю класса через экземпляр класса
# print("Спрашивает Красный:", red.name)
# # Обращение к полю класса через экземпляр класса
# print("Спрашивает Зеленый:", green.name)
#
# # Поле объекта класса и поле экземпляра класса
# class MyClass:
#     # поле класса
#     name = "Класс MyClass"
#     # Метод для присваивания значения
#     # полю экземпляра класса
#     def set(self, n):
#         self.nickname = n
#     # поля экземпляра класса
#     def get(self):
#         print("Значение поля:", self.nickname)
#     # конструктор класса
#     def __init__(self, n):
#         # полю экземпляра класса
#         # присваивается значение
#         self.set(n)
#         # Отображается сообщение
#         print("Создан экземпляр класса.")
#         self.get()
# green = MyClass("Зеленый")
# # Обращение к полю класса через экземпляр класса
# print("Принадлежность:", green.name)
# # создается второй экщемпляр класса
# red = MyClass("Красный")
# # обращение к полю класса через экземпляр класса
# print("Принадлежность:", red.name)
# # полю класса присваивается значение
# green.name = "Здесь был Зеленый!"
# # Обращение к полю класса через экземпляр класса
# print("Спрашивает Красный:", red.name)
# # Обращение к полю класса через экземпляр класса
# print("Спрашивает Зеленый:", green.name)
# MyClass.name = "Здесь могла быть Ваша реклама!"
# print("Спрашивает Красный:", red.name)
# # Обращение к полю класса через экземпляр класса
# print("Спрашивает Зеленый:", green.name)
# # удаляем поле экземпляра green
# del green.name
# print("Спрашивает Зеленый:", green.name)
#
# # Добавление и удаление полей и методов
# # Добавление и удаление полей
# class MyClass:
#     pass
# # создаем экземпляр A
# A = MyClass()
# # создаем экземпляр B
# B = MyClass()
# # экземпляру A
# # добавляем поле first
# A.first = "Экземпляр класса A"
# # экземпляру B
# # добавляем поле second
# B.second = "Экземпляр класса B"
# # Классу MyClass добавляем поле total
# MyClass.total = "Класс MyClass"
# # Проверяем доступ к полям total и
# # first через ссылку на экземпляр A
# print(A.total, "->", A.first)
# # Проверяем доступ к полю second
# # через ссылку на экземпляр класса A
# try:
#     # если поле есть
#     print(A.second)
# except AttributeError:
#     # если поля нет
#     print("Такого поля у экземпляра класса A нет!")
# # Проверяем доступ к полям total и second
# # через ссылку на экземпляр класса B
# print(B.total, "->", B.second)
# # Проверяем доступ к полю first
# # через ссылку на экземпляр класса B
# try:
#     # если поле есть
#     print(B.first)
# except AttributeError:
#     # если поля нет
#     print("Такого поля у экземпляра класса B нет!")
# # Удаляем поле total класса MyClass
# del MyClass.total
# # Проверяем доступ к полю total
# # через ссылку на экземпляр А
# try:
#     # если поле есть
#     print(A.total)
# except AttributeError:
#     # если поля нет
#     print("Такого поля нет!")
# # Проверяем достуа к полю total
# # через ссылку на экземпляр B
# try:
#     # если поле есть
#     print(B.total)
# except AttributeError:
#     # если поля нет
#     print("Такого поля нет!")
# # удаляем поле first экземпляра A
# del A.first
# # Проверяем доступ к полю first
# # через ссылку на экземпляр A
# try:
#     # Если поле есть
#     print(A.first)
# except AttributeError:
#     # Если поля нет
#     print("Такого поля у экземпляра класса А нет!")
#
# # Добавление и удаление методов
# class MyClass:
#     def say(self):
#         print("Всем привет!")
# obj = MyClass()
# # это метод
# obj.say()
# # это функция
# MyClass.say(obj)
# MyClass.say("Какой-то текст")
# print(type(MyClass.say))
# print(type(obj.say))
#
# # Добавление и удаление методов
# class MyClass:
#     pass
# A = MyClass()
# B = MyClass()
# C = MyClass()
# # Создаем первую функцию
# def hello():
#     print("Метод экземпляра - 'hello'")
# # Создаем вторую функцию
# def hi():
#     print("Ещё один метод - 'hi'")
# # Определяем метод экземпляра
# A.say = hello
# C.say = hi
# A.say()
# try:
#     B.say()
# except AttributeError:
#     print("Такого метода нет!")
# C.say()
# try:
#     MyClass.say()
# except AttributeError:
#     print("Такой функции нет")
# del A.say
# try:
#     A.say()
# except AttributeError:
#     print("Такого метода нет")
# C.say()
#
# # Добавление и удаление функции класса
# class MyClass:
#     def __init__(self,n):
#         self.name = n
#     # создаем экземпляры класса
# A = MyClass("A")
# B = MyClass("B")
# # создаём функцию с аргументами
# def hello(self):
#     print("Это экземпляр", self.name, "- hello")
# # создаём функцию с аргументами
# def hi(self):
#     print(self.name + ": hi")
# # Определяем функцию класса
# MyClass.say = hello
# # Вызываем метод экземпляра
# A.say()
# # Вызываем метод экземпляра
# B.say()
# # Вызываем функцию класса
# MyClass.say(A)
# MyClass.say(B)
# # Меняем ссылку на функцию
# MyClass.say = hi
# A.say()
# B.say()
# MyClass.say(A)
# MyClass.say(B)
# # удаляем функцию класса
# del MyClass.say
# # Вызываем метод экземпляра
# try:
#     A.say()
# except AttributeError:
#     print("Такого метода нет")
# # Вызываем метод экземпляра
# try:
#     B.say()
# except AttributeError:
#     print("Такого метода нет")
# # Вызываем функцию класса
# try:
#     MyClass.say(A)
# except AttributeError:
#     print("Такой функции нет")


# Операции с методами и функциями
# Создаем класс
# class MyClass:
#     # Конструктор экземпляра класса
#     def __init__(self, n):
#         self.name = n
#     # Метод экземпляра класса
#     def say(self):
#         print("Класс MyClass:", self.name)
# # Создаем экземпляры класса
# A = MyClass("A")
# B = MyClass("B")
# # Вызываем метод экземпляра
# A.say()
# B.say()
# # Ссылку на метод записываем в переменную
# F = A.say
# # Вызываем функцию
# F()
# # Атриуту экземпляра присваивается текст
# A.say = "Поле экземпляра А"
# # Проверяем значение поля
# print(A.say)
# # пытаемся вызвать метод экземпляра
# try:
#     A.say()
# except TypeError:
#     print("Неверная команда")
# # Вызываем метод экземпляра
# B.say()
# # Вызываем функцию
# F()
#
# Копирование экземпляров и конструктор создания копии

# импортируем из модуля copy функции copy() и deepcopy() -> в самом начале программы
#
# class MyClass:
#     # конструктор
#     def __init__(self, name, nums):
#         # значение поля name
#         self.name = name
#         # значение поля nums
#         self.nums = nums
#         # метод для отображения
#         # значений полей экземпляров
#     def show(self):
#         print("name ->", self.name)
#         print("nums ->", self.nums)
# x = MyClass("Python",[1, 2, 3])
# print("Экземпляр x:")
# x.show()
# # поверхностная копия экземпляра x
# y = copy(x)
# # полная копия экземпляра x
# z = deepcopy(x)
# # отображение полей экземпляра y
# y.show()
# # отображение полей экземпляра z
# z.show()
# # Изменение значения поля name
# # экземпляра x
# x.name = "Java"
# # Изменение значения поля nums
# # экземпляра x
# x.nums[0] = 0
# print("Экземпляр x:")
# x.show()
# print("Экземпляр y:")
# y.show()
# print("Экземпляр z:")
# z.show()

# Конструктор создания копии экземпляра
# class ComplNum:
#     def __init__(self, x=0, y=0):
#         # Если аругемент x - экземпляр
#         # класса ComplNum
#         if type(x) == ComplNum:
#             # Значения поля Re
#             self.Re = x.Re
#             # Значения поля Im
#             self.Im = x.Im
#         else:
#             # Значения поля Re
#             self.Re = x
#             # Значения поля Im
#             self.Im = y
#     # метод для отображения значений
#     # полей экземпляра класса
#     def show(self):
#         print("Re =", self.Re)
#         print("Im =", self.Im)
# # создаем экземпляр класса
# a = ComplNum(1,2)
# # создаем копию экземпляра класса
# b = ComplNum(a)
# print("Экземпляр a:")
# a.show()
# print("Экземпляр b:")
# b.show()
# print("Поля экземпляра a изменяются!")
# # Изменяем значение поля исходного экземпляра
# a.Re = 10
# a.Im = 20
# print("Экземпляр a:")
# # Значение полей исходного экземпляра
# a.show()
# print("Экземпляр b:")
# # Значение полей экземпляра копии
# b.show()

# # Конструктор создания копии и поля списка
# class MyClass:
#     def __init__(self, arg, nums=None):
#         # Если аргумент arg - ссылка на
#         # экземпляр класса MyClass
#         if type(arg) == MyClass:
#             self.name = arg.name[:]
#             self.nums = arg.nums[:]
#         else:
#             self.name = arg
#             self.nums = nums
#     def show(self):
#         print("name ->", self.name)
#         print("name ->", self.nums)
#
# x = MyClass("Python", [1,2,3])
# print("Экземпляр x:")
# x.show()
# y = MyClass(x)
# y.show()
# print("Поля экземпляра x изменяются!")
# x.name = "Java"
# x.nums[0] = 0
# print("Экземпляр x:")
# x.show()
# print("Экземпляр y:")
# y.show()
#
# # Наследование классов
# class BaseClass:
#     # поле базового класса
#     name_base = "Класс BaseClass"
#     def say_base(self):
#         print("Метод say_base()")
# # производный класс
# class NewClass(BaseClass):
#     # поле производного класса
#     name_new = "Класс NewClass"
#     # метод экземпляра производного класса
#     def say_new(self):
#         print("Метод say_new()")
# # экземпляр базового класса
# obj_base = BaseClass()
# # экземпляр производного класса
# obj_new = NewClass()
# print("Класс BaseClass и экземпляр obj_base:")
# # поле базового класса
# print(BaseClass.name_base)
# # метод экземпляра базового класса
# obj_base.say_base()
# print("Класс NewClass и экземпляр obj_new:")
# # Поле производного класса
# print(NewClass.name_base)
# # Метод экземпляра производного класса
# obj_new.say_base()
# # Унаследованное из базового класса
# # поле производного класса
# print(NewClass.name_new)
# # Унаследованное из базового класса
# # метод экземпляра производного класса
# obj_new.say_new()

# изменение базового класса
# class BaseClass:
#     #  поле базового класса
#     name = "Поле name"
#     # метод экземпляра базового класса
#     def say(self):
#         print("Метод say()")
# class NewClass(BaseClass):
#     pass
# obj = NewClass()
# print(NewClass.name)
# obj.say()
# def hello(self):
#     print("Новый метод hello()")
# # Изменяем ссылку на функцию
# # в базовом классе
# BaseClass.say = hello
# # Изменяем значение поля name
# # в базовом классе
# BaseClass.name = "Новое значение поля name"
# # Проверяем значение поля в производном классе
# print(NewClass.name)
# # вызываем метод из экземпляра
# # производного класса
# obj.say()
#
# # Переопределение поле и методов
#
# class BaseClass:
#     name = "Поле name базового класса"
#     def say(self):
#         print("Метод say() базового класса")
# class NewClass(BaseClass):
#     name = "Поле name производного класса"
#     def say(self):
#         print("Метод say() производного класса")
#
# obj_base = BaseClass()
# obj_new = NewClass()
# print(obj_base.name)
# obj_base.say()
# print(obj_new.name)
# obj_new.say()
#
# # Переопределение методов
# class BaseClass:
#     def __init__(self, num):
#         self.id = num
#     def get(self):
#         print("ID:", self.id)
#     # Метод экземпляра базового класса
#     def show(self):
#         print("Поле экземпляра базового класса")
#         self.get()
# # производный класс
# class NewClass(BaseClass):
#     def __init__(self, num, txt):
#         # вызываем конструктор экземпляра базового класса
#         super().__init__(num)
#         self.name = txt
#     def get(self):
#         # вызываем версию метода get() базового класса
#         # можно было сделать так: BaseClass.get(self) (второй вариант)
#         super().get()
#         print("Name:", self.name)
# # экземпляр базового класса
# obj_base = BaseClass(1)
# print("Вызываем метод show() из экземпляра obj_base:")
# # Вызов метода экземпляра базового класса
# obj_base.show()
# # Экземпляр произовдного класса
# obj_new = NewClass(10, "десятка")
# print("Вызываем метод show() из экземпляра obj_new:")
# # Вызов метода экземпляра производного класса
# obj_new.show()

# Множественное наследование
# Наследование нескольких базовых классов

# Первый базовый класс
# class BoxSize:
#     # конструктор
#     def __init__(self, width, height, depth):
#         self.width = width
#         self.height = height
#         self.depth = depth
#     # метод для вычисления объёма
#     def volume(self):
#         # результат - произведение полей экземпляра
#         return self.width * self.height * self.depth
#     # метод для отображения значений поле экземпляра
#     # и результата вызова метода volume()
#     def show(self):
#         print("Размеры ящика:")
#         print("Ширина:", self.width)
#         print("Высота:", self.height)
#         print("Глубина:", self.depth)
#         # Результат вызова метода volume()
#         print("Объём:", self.volume())
# # второй базовый класс
# class BoxParams:
#     def __init__(self, weight, color):
#         self.weight = weight
#         self.color = color
#     # метод для отображения значений поля экземпляра
#     def show(self):
#         print("Дополнительные параметры ящика:")
#         print("Вес (масса):", self.weight)
#         print("Цвет:", self.color)
# # Производный класс
# class Box(BoxSize,BoxParams):
#     def __init__(self, width, height, depth, weight, color):
#         # вызов конструктора первого базового класса
#         BoxSize.__init__(self, width, height, depth)
#         # вызов конструктора второго базового класса
#         BoxParams.__init__(self, weight, color)
#         # вызываем метод show() экземпляра класса
#         self.show()
#     def show(self):
#         # Вызываем метод show() из первого базового класса
#         BoxSize.show(self)
#         # Вызываем метод show() из второго базового класса
#         BoxParams.show(self)
# # Создаем экземпляр производного класса
# obj = Box(10,20,30,5,"зеленый")
# 
# # Многократное наследование
# # Описываем классы
# class Alpha:
#     def hi():
#         print("Класс Alpha")
# class Bravo:
#     def hi():
#         print("Класс Bravo")
# class Charlie:
#     def hi():
#         print("Класс Charlie")
# class Delta(Alpha):
#     pass
# class Echo(Delta):
#     pass
# class Foxtrot(Bravo, Alpha):
#     pass
# class Golf(Foxtrot):
#     pass
# class Hotel(Echo, Charlie, Golf):
#     pass
# # вызываем функции классов
# Echo.hi()
# Golf.hi()
# Hotel.hi()
# # выводим "цепочку наследования" для производного класса
# # для этого используем поле __mro__
# print(Hotel.__mro__)

# Специальные поля

class Alpha:
    "Класс Alpha и внутренний класс Bravo"
    def hello():
        pass
    # Внутренний класс Bravo
    class Bravo:
        pass
# Производный от Alpha класс
class Charlie(Alpha):
    pass
# Производный от Charlie класс
class Delta(Charlie):
    pass

obj = Alpha()
# Поле __class__ экземпляра класса
# Определяем класс, на основе которого создавался экземпляр.
print("\nПоле __class__")
print("Экзмпляр obj:", obj.__class__)
print("Класс Alpha.Bravo:", Alpha.Bravo.__class__)
print("Класс Charlie:", Charlie.__class__)
# Поля __basses__ и __mro__
# mro - возвращает цепочку наследования класса
# basses - возвращает список базовых классов
print("\nПоля __basses__ и __mro__")
print("Класс Delta, поле __basses__:",Delta.__bases__)
print("Класс Delta, поле __mro__:",Delta.__mro__)
print("Класс Alpha, поле __basses__:",Alpha.__bases__)
print("Класс Alpha, поле __mro__:",Alpha.__mro__)
# Поле __doc__
# возвращает текст документации класса(то что в классе "" первая строка)
# или присвоить полю значение
print("\nПоле __doc__")
print("Описание класса Alpha:",Alpha.__doc__)
Delta.__doc__ = "Класс Delta наследует класс Charlie"
print("Описание класса Delta:", Delta.__doc__)
# Поле __module__
# возвращает модуль класса
print("\nПоле __module__")
print("Модуль класса Alpha:",Alpha.__module__)
# Поле __dict__
# Возвращает словарь с атрибутами класса
print("\nПоле __dict__")
print("Атрибуты класса Alpha:",Alpha.__dict__)
print("Атрибуты класса Alpha.Bravo:",Alpha.Bravo.__dict__)
print("Атрибуты класса Delta:",Delta.__dict__)
# Поле __name__ и __qualname__
# __name__ - возвращает имя класса
# __qualname__ - возращает полное имя класса(отображает структуру вложенных классов)
print("\nПоле __name__ и __qualname__")
print("Класс Alpha, поле __name__:",Alpha.__name__)
print("Класс Alpha, поле __qualname__:",Alpha.__qualname__)
print("Класс Alpha.Bravo, поле __name__:",Alpha.Bravo.__name__)
print("Класс Alpha.Bravo, поле __qualname__:",Alpha.Bravo.__qualname__)
print("Класс Delta, поле __name__:", Delta.__name__)
print("Класс Delta, поле __qualname__:", Delta.__qualname__)
# dir() - позволяет получить список полей и методов экземпляра класса
print(dir(Alpha))

# Определение метода __call__()
class Box:
    def __init__(self, width, height, depth):
        # поля экземпляра класса
        self.width = width
        self.height = height
        self.depth = depth
    # определение метода __call__()
    def __call__(self):
        # Вычисляется произведение полей экземпляра
        volume = self.width*self.height*self.depth
        print("Объём равен", volume)
# Создаём экземпляр класса
obj = Box(10, 20, 30)
# Вызываем экземпляр класса как функцию
obj()

# метод __call__() с аргументами
class Box:
    def __init__(self, width, height, depth):
        print("Объём равен", self(width, height, depth))
    # определение метода __call__()
    def __call__(self, width, height, depth):
        # поля экземпляра класса
        self.width = width
        self.height = height
        self.depth = depth
        # вычисляется произведение полей экземпляра
        volume = self.width * self.height * self.depth
        # возвращаемый результат
        return volume
# Создаём экземпляр класса
obj = Box(10, 20, 30)
# вызываем экземпляр как функцию
print("Новое значение", obj(1, 2, 3))

# Методы приведения к типу
class MyClass:
    def __init__(self, nums):
        # создаём поле - пустой список
        self.nums = list()
        # Оператор цикла для перебора
        # элементов в аргументе nums
        # (это список или множество)
        for n in nums:
            # Добавляем новый элемент в список 
            self.nums.append(n)
    # Метод для приведения к типу str
    def __str__(self):
        # Начальное значение текстовой строки
        txt = "Значение поля-списка:\n| "
        # Перебираем элементы в списке nums- поле
        # экземпляра класса
        for n in self.nums:
            # Дополняем строку новым текстом
            txt += str(n) + " | "
        # Результат метода
        return txt
    # Метод для приведения к типу int
    def __int__(self):
        # Результат метода (кол-во элементов
        # в списке nums - поле экземпляра класса)
        return len(self.nums)
    # Метод для приведеемя к типу float
    def __float__(self):
        # Среднее значение элементов в
        # списке nums - поле экземпляра
        avg = sum(self.nums)/int(self)
        # Результат метода
        return avg
    # Метод для приведения к типу bool
    def __bool__(self):
        # если нечетное кол-во элементов
        if int(self) % 2 == 1:
            return True
        # если кол-во элементов чётное
        else:
            # результат метода
            return False
    # Метод для приведения к типу complex
    def __complex__(self):
        # Минимальное из чисел в списке
        mn = min(self.nums)
        # Максимальное из чисел в списке
        mx = max(self.nums)
        # Комплексное число
        z = complex(mx, mn)
        # результат метода
        return z
# Создаем экземпляр класса
obj = MyClass({2.8, 4.1, 7.5, 2.5, 3.2})
# Выводим на печать экземпляр
# (преобразование к типу str)
print(obj)
# Приведение к типу int
print("Элементов в списке:", int(obj))
# Приведение к типу bool
# если obj == True
if obj:
    print("Нечетное кол-во элементов")
# Приведение к типу float
print("Среднее значение:", float(obj))
# Преобразование к типу complex
print("Минимум и максимум:", complex(obj))

# "Округление" экземпляра и другие операции
class MyClass:
    def __init__(self,txt):
        # присваиваем значение полю экземпляра
        self.name = txt
    # метод для приведения к текстовому типу
    def __str__(self):
        # результат метода - значение
        # поля name экземпляра класса
        return self.name
    # метод для вычисления "длины"
    # экземпляра класса функцией len()
    def __len__(self):
        # Результат метода кол-во символов
        # в поле name экземпляра класса
        return len(self.name)
    # Метод, который вызывается при использовании
    # функций bin(), oct(), hex()
    def __index__(self):
        # Кол-во пробелов плюс единица
        p = self.name.count(" ") + 1
        return p
    def __round__(self):
        # присваиваем значение поле name
        self.name = "Сброс значения"
        # Результат - ссылка на экземпляр класса
        return self
# Начальное текстовое значение
txt = "Раз, два, три, четыре, пять. "
# уточняем текстовое значение
txt += "\nВышел зайчик погулять."
# создаем экземпляр класса
obj = MyClass(txt)
# печатаем экземпляр в окно вывода
print(obj)
# вычисляем кол-во символов в поле name
print("Кол-во символов в поле name:", len(obj))
# Кол-во слов (пробелов) в поле name
print("Кол-во слов:", obj.__index__())
# Двоичный код
print("В двоичном коде:", bin(obj))
# Восьмиричный код
print("В восьмиричном коде:", oct(obj))
# Шестнадцатиричный код
print("В шестнадцатиричном коде:", hex(obj))
# Выполняется "округление" экземпляра
print(round(obj))
# Выводим на печать экземпляр
print(obj)

